// Problem: Pascal's Triangle
// LeetCode Link: https://leetcode.com/problems/pascals-triangle/
// Difficulty: Easy
// Topic: Arrays, Dynamic Programming
//
// Approach:
// The solution uses an iterative approach, building the triangle row by row. 
// For each new row, the elements are generated by summing the adjacent elements 
// from the previous row. Each row starts and ends with 1. This method leverages 
// the property that Pascal's Triangle is a form of dynamic programming.
//
// Time Complexity: O(numRows^2)
// The outer loop runs numRows times, and the inner loop runs proportional to the row size (i), 
// resulting in 1 + 2 + ... + (numRows-1) operations, which simplifies to O(numRows^2).
//
// Space Complexity: O(numRows^2)
// The space is used to store the entire triangle structure, which has a total of 
// numRows * (numRows + 1) / 2 elements.

class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> list = new ArrayList<>();
        list.add(new ArrayList<>(Arrays.asList(1)));
        
        for(int i=1; i < numRows; i++){
            ArrayList<Integer> insideList = new ArrayList<>();
            insideList.add(1);
            
            // Get the last row added to the list
            List<Integer> lastRow = list.get(list.size() - 1);
            int n = lastRow.size();
            
            // Calculate inner elements by summing adjacent elements of the last row
            for(int k=1; k < n; k++){
                int sum = lastRow.get(k - 1) + lastRow.get(k);
                insideList.add(sum);
            }
            
            insideList.add(1);
            list.add(insideList);
        }
        
        return list;
    }
}